<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <title>RTree Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      .node {
        fill: #fff;
        stroke: #000;
        stroke-width: 1px;
      }
      .leaf {
        fill: #e8f5e9;
      }
      .internal {
        fill: #e3f2fd;
      }
      .link {
        fill: none;
        stroke: #999;
        stroke-width: 1px;
        stroke-opacity: 0.6;
      }
      .mbr {
        fill: none;
        stroke-width: 1.5px;
        stroke-opacity: 0.8;
      }
      .mbr-level-0 {
        stroke: #ff0000;
      } /* 빨 */
      .mbr-level-1 {
        stroke: #ff8000;
      } /* 주 */
      .mbr-level-2 {
        stroke: #ffff00;
      } /* 노 */
      .mbr-level-3 {
        stroke: #00ff00;
      } /* 초 */
      .mbr-level-4 {
        stroke: #0000ff;
      } /* 파 */
      .mbr-level-5 {
        stroke: #000080;
      } /* 남 */
      .mbr-level-6 {
        stroke: #800080;
      } /* 보 */
      #tree-container {
        width: 100%;
        height: 800px;
        border: 1px solid #ccc;
        margin: 20px 0;
        overflow: hidden;
        background-color: #fafafa;
      }
      #mbr-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ccc;
        margin: 20px 0;
        overflow: hidden;
        background-color: #fff;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      .stats {
        margin: 20px 0;
        padding: 20px;
        background-color: #f5f5f5;
        border-radius: 4px;
      }
      .node text {
        font-size: 11px;
        font-family: Arial, sans-serif;
        pointer-events: none;
      }
      .leaf text {
        fill: #2e7d32;
      }
      .internal text {
        fill: #1565c0;
      }
      .node circle {
        cursor: pointer;
      }
      .node:hover circle {
        stroke: #1976d2;
        stroke-width: 2px;
      }
      .grid line {
        stroke: #e0e0e0;
        stroke-width: 0.5;
      }
      .level-controls {
        margin: 10px 0;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .level-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .level-control input[type="checkbox"] {
        margin: 0;
      }
      .color-indicator {
        display: inline-block;
        width: 20px;
        height: 3px;
        vertical-align: middle;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>RTree Visualization</h1>

      <div class="stats">
        <h2>Tree Statistics</h2>
        <p>Total Nodes: <span id="total-nodes">0</span></p>
        <p>Leaf Nodes: <span id="leaf-nodes">0</span></p>
        <p>Internal Nodes: <span id="internal-nodes">0</span></p>
        <p>Tree Depth: <span id="tree-depth">0</span></p>
        <p>
          <em>Note: Visualization is limited to 3 depth levels for clarity</em>
        </p>
      </div>

      <h2>Tree Structure</h2>
      <div id="tree-container"></div>

      <h2>MBR Visualization</h2>
      <div class="level-controls" id="level-controls">
        <!-- Will be populated dynamically -->
      </div>
      <div id="mbr-container"></div>
    </div>

    <script th:inline="javascript">
      const treeData = /*[[${treeData}]]*/ null;

      // Tree visualization
      function renderTree() {
        const width = document.getElementById("tree-container").clientWidth;
        const height = document.getElementById("tree-container").clientHeight;

        // 트리 레이아웃 크기 조정
        const tree = d3
          .tree()
          .nodeSize([50, 70]) // 노드 간 간격 설정 [가로, 세로]
          .separation((a, b) => (a.parent === b.parent ? 1.2 : 2)); // 형제 노드 간 간격 설정

        const root = d3.hierarchy(treeData);
        const treeLayout = tree(root);

        // SVG 생성 및 중앙 정렬
        const svg = d3
          .select("#tree-container")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", `translate(${width / 2}, 30)`);

        // 줌 기능 추가
        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 3])
          .on("zoom", (event) => {
            svg.attr("transform", event.transform);
          });

        d3.select("#tree-container svg")
          .call(zoom)
          .call(zoom.translateTo, 0, 0);

        // Links
        svg
          .selectAll(".link")
          .data(treeLayout.links())
          .enter()
          .append("path")
          .attr("class", "link")
          .attr(
            "d",
            d3
              .linkVertical()
              .x((d) => d.x)
              .y((d) => d.y)
          );

        // Nodes
        const nodes = svg
          .selectAll(".node")
          .data(treeLayout.descendants())
          .enter()
          .append("g")
          .attr("transform", (d) => `translate(${d.x},${d.y})`);

        nodes
          .append("circle")
          .attr("class", (d) => `node ${d.data.isLeaf ? "leaf" : "internal"}`)
          .attr("r", 5);

        nodes
          .append("text")
          .attr("dy", 20)
          .attr("text-anchor", "middle")
          .text((d) => `Size: ${d.data.size}`);

        // Update statistics
        updateStats(treeData);
      }

      // MBR visualization
      function renderMBR() {
        const width = document.getElementById("mbr-container").clientWidth;
        const height = document.getElementById("mbr-container").clientHeight;

        // Find the bounds of all MBRs
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        function traverseForBounds(node) {
          const mbr = node.mbr;
          minX = Math.min(minX, mbr.minX);
          minY = Math.min(minY, mbr.minY);
          maxX = Math.max(maxX, mbr.maxX);
          maxY = Math.max(maxY, mbr.maxY);
          node.children.forEach(traverseForBounds);
        }
        traverseForBounds(treeData);

        // Add some padding to the bounds
        const padding = 0.02;
        const dx = maxX - minX;
        const dy = maxY - minY;
        minX -= dx * padding;
        maxX += dx * padding;
        minY -= dy * padding;
        maxY += dy * padding;

        // Create scales
        const xScale = d3
          .scaleLinear()
          .domain([minX, maxX])
          .range([50, width - 50]);
        const yScale = d3
          .scaleLinear()
          .domain([minY, maxY])
          .range([height - 50, 50]);

        // Get max depth first
        let maxDepth = 0;
        function findMaxDepth(node, depth = 0) {
          maxDepth = Math.max(maxDepth, depth);
          if (node.children) {
            node.children.forEach((child) => findMaxDepth(child, depth + 1));
          }
        }
        findMaxDepth(treeData);

        // Create level controls
        const levelColors = [
          "#ff0000", // 빨
          "#ff8000", // 주
          "#ffff00", // 노
          "#00ff00", // 초
          "#0000ff", // 파
          "#000080", // 남
          "#800080", // 보
        ];

        const controls = document.getElementById("level-controls");
        controls.innerHTML = ""; // Clear existing controls

        // Add "Select All" checkbox
        const allControl = document.createElement("div");
        allControl.className = "level-control";
        allControl.innerHTML = `
          <input type="checkbox" id="level-all" checked>
          <label for="level-all">모든 레벨</label>
        `;
        controls.appendChild(allControl);

        // Add individual level checkboxes
        for (let i = 0; i <= maxDepth; i++) {
          const control = document.createElement("div");
          control.className = "level-control";
          control.innerHTML = `
            <input type="checkbox" id="level-${i}" class="level-checkbox" checked>
            <div class="color-indicator" style="background-color: ${levelColors[i]}"></div>
            <label for="level-${i}">Level ${i}</label>
          `;
          controls.appendChild(control);
        }

        // Handle checkbox events
        document
          .getElementById("level-all")
          .addEventListener("change", function (e) {
            document.querySelectorAll(".level-checkbox").forEach((cb) => {
              cb.checked = e.target.checked;
            });
            updateVisibility();
          });

        document.querySelectorAll(".level-checkbox").forEach((checkbox) => {
          checkbox.addEventListener("change", function () {
            updateVisibility();
            // Update "Select All" checkbox
            const allChecked = Array.from(
              document.querySelectorAll(".level-checkbox")
            ).every((cb) => cb.checked);
            document.getElementById("level-all").checked = allChecked;
          });
        });

        function updateVisibility() {
          const selectedLevels = Array.from(
            document.querySelectorAll(".level-checkbox")
          ).map((cb, index) => ({ level: index, visible: cb.checked }));

          d3.selectAll(".mbr").style("display", function () {
            const level = this.classList.toString().match(/mbr-level-(\d+)/)[1];
            return selectedLevels[level].visible ? "block" : "none";
          });
        }

        const svg = d3
          .select("#mbr-container")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g");

        // Add zoom
        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 10])
          .on("zoom", (event) => {
            svg.attr("transform", event.transform);
          });

        d3.select("#mbr-container svg").call(zoom).call(zoom.translateTo, 0, 0);

        // Add grid
        const grid = svg.append("g").attr("class", "grid");

        // X-axis grid
        grid
          .selectAll(".grid-line-x")
          .data(xScale.ticks(10))
          .enter()
          .append("line")
          .attr("class", "grid-line")
          .attr("x1", (d) => xScale(d))
          .attr("x2", (d) => xScale(d))
          .attr("y1", 0)
          .attr("y2", height);

        // Y-axis grid
        grid
          .selectAll(".grid-line-y")
          .data(yScale.ticks(10))
          .enter()
          .append("line")
          .attr("class", "grid-line")
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", (d) => yScale(d))
          .attr("y2", (d) => yScale(d));

        // Render MBRs level by level, starting from the deepest level
        function renderMBRsByLevel() {
          // Create arrays to hold nodes at each level
          const levelNodes = Array.from({ length: maxDepth + 1 }, () => []);

          // Group nodes by level
          function groupByLevel(node, depth = 0) {
            levelNodes[depth].push(node);
            if (node.children) {
              node.children.forEach((child) => groupByLevel(child, depth + 1));
            }
          }
          groupByLevel(treeData);

          // Render levels from deepest to root
          for (let depth = maxDepth; depth >= 0; depth--) {
            levelNodes[depth].forEach((node) => {
              const mbr = node.mbr;
              svg
                .append("rect")
                .attr("class", `mbr mbr-level-${depth}`)
                .attr("x", xScale(mbr.minX))
                .attr("y", yScale(mbr.maxY))
                .attr("width", xScale(mbr.maxX) - xScale(mbr.minX))
                .attr("height", yScale(mbr.minY) - yScale(mbr.maxY))
                .append("title")
                .text(`Level: ${depth}, Size: ${node.size}`);
            });
          }
        }

        // Start rendering
        renderMBRsByLevel();
      }

      function updateStats(data) {
        let totalNodes = 0;
        let leafNodes = 0;
        let internalNodes = 0;
        let maxDepth = 0;

        function traverse(node, depth) {
          totalNodes++;
          if (node.isLeaf) {
            leafNodes++;
          } else {
            internalNodes++;
          }
          maxDepth = Math.max(maxDepth, depth);
          node.children.forEach((child) => traverse(child, depth + 1));
        }
        traverse(data, 0);

        document.getElementById("total-nodes").textContent = totalNodes;
        document.getElementById("leaf-nodes").textContent = leafNodes;
        document.getElementById("internal-nodes").textContent = internalNodes;
        document.getElementById("tree-depth").textContent = maxDepth;
      }

      // Render visualizations when the page loads
      if (treeData) {
        renderTree();
        renderMBR();
      }
    </script>
  </body>
</html>
