<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <title>RTree MBR Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      #mbr-container {
        width: 100%;
        height: 800px;
        border: 1px solid #ccc;
        margin: 20px 0;
        overflow: hidden;
        background-color: #fafafa;
      }
      .level-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
        margin-bottom: 10px;
      }
      .level-control {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .color-indicator {
        width: 20px;
        height: 20px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      .mbr {
        fill: none;
        stroke-width: 1.5px;
        stroke-opacity: 0.8;
        pointer-events: none;
      }
      .mbr-level-0 {
        stroke: #ff0000;
      } /* 빨강 - 루트 */
      .mbr-level-1 {
        stroke: #ff7f00;
      } /* 주황 */
      .mbr-level-2 {
        stroke: #ffff00;
      } /* 노랑 */
      .mbr-level-3 {
        stroke: #00ff00;
      } /* 초록 */
      .mbr-level-4 {
        stroke: #0000ff;
      } /* 파랑 */
      .mbr-level-5 {
        stroke: #4b0082;
      } /* 남색 */
      .mbr-level-6 {
        stroke: #9400d3;
      } /* 보라 */
      .mbr-level-7 {
        stroke: #800080;
      } /* 자주색 */
      .mbr-level-8 {
        stroke: #008080;
      } /* 청록색 */
      .mbr-level-9 {
        stroke: #808000;
      } /* 올리브색 */
      .mbr-level-10 {
        stroke: #800000;
      } /* 갈색 */
      [class^="mbr-level-"] {
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>RTree MBR Visualization</h1>
      <div class="level-controls">
        <div class="level-control">
          <input type="checkbox" id="all-levels" checked />
          <label for="all-levels">All Levels</label>
        </div>
      </div>

      <div id="mbr-container"></div>
    </div>

    <script th:inline="javascript">
      const treeData = /*[[${treeData}]]*/ null;

      function createLevelControls(maxDepth) {
        const levelControls = document.querySelector(".level-controls");
        const colors = [
          "#ff0000", // 빨강 - 루트
          "#ff7f00", // 주황
          "#ffff00", // 노랑
          "#00ff00", // 초록
          "#0000ff", // 파랑
          "#4b0082", // 남색
          "#9400d3", // 보라
          "#800080", // 자주색
          "#008080", // 청록색
          "#808000", // 올리브색
          "#800000", // 갈색
        ];
        const levelNames = [
          "루트 레벨",
          "레벨 1",
          "레벨 2",
          "레벨 3",
          "레벨 4",
          "레벨 5",
          "레벨 6",
          "레벨 7",
          "레벨 8",
          "레벨 9",
          "레벨 10",
        ];

        for (let i = 0; i <= maxDepth; i++) {
          const control = document.createElement("div");
          control.className = "level-control";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `level-${i}`;
          checkbox.checked = true;
          checkbox.addEventListener("change", updateVisibility);

          const colorIndicator = document.createElement("div");
          colorIndicator.className = "color-indicator";
          const colorIndex = i % colors.length;
          colorIndicator.style.backgroundColor = colors[colorIndex];
          colorIndicator.title = `Level ${i} - ${colors[colorIndex]}`;

          const label = document.createElement("label");
          label.htmlFor = `level-${i}`;
          label.textContent =
            i < levelNames.length ? levelNames[i] : `레벨 ${i}`;

          control.appendChild(checkbox);
          control.appendChild(colorIndicator);
          control.appendChild(label);
          levelControls.appendChild(control);
        }

        document
          .getElementById("all-levels")
          .addEventListener("change", (e) => {
            const checkboxes = document.querySelectorAll(
              '.level-control input[type="checkbox"]'
            );
            checkboxes.forEach((cb) => {
              if (cb.id !== "all-levels") {
                cb.checked = e.target.checked;
              }
            });
            updateVisibility();
          });
      }

      function updateVisibility() {
        const allLevels = document.getElementById("all-levels");
        const levelCheckboxes = Array.from(
          document.querySelectorAll('.level-control input[type="checkbox"]')
        ).filter((cb) => cb.id !== "all-levels");

        levelCheckboxes.forEach((cb, i) => {
          const mbrs = document.querySelectorAll(`.mbr-level-${i}`);
          mbrs.forEach((mbr) => {
            mbr.style.display = cb.checked ? "block" : "none";
          });
        });

        allLevels.checked = levelCheckboxes.every((cb) => cb.checked);
      }

      function renderMBRs() {
        const width = document.getElementById("mbr-container").clientWidth;
        const height = document.getElementById("mbr-container").clientHeight;

        // Find the bounds of all MBRs
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        function traverseForBounds(node) {
          const mbr = node.mbr;
          minX = Math.min(minX, mbr.minX);
          minY = Math.min(minY, mbr.minY);
          maxX = Math.max(maxX, mbr.maxX);
          maxY = Math.max(maxY, mbr.maxY);
          if (node.children) {
            node.children.forEach(traverseForBounds);
          }
        }
        traverseForBounds(treeData);

        // Add some padding to the bounds
        const padding = 0.02;
        const dx = maxX - minX;
        const dy = maxY - minY;
        minX -= dx * padding;
        maxX += dx * padding;
        minY -= dy * padding;
        maxY += dy * padding;

        // Create scales
        const xScale = d3
          .scaleLinear()
          .domain([minX, maxX])
          .range([50, width - 50]);
        const yScale = d3
          .scaleLinear()
          .domain([minY, maxY])
          .range([height - 50, 50]);

        const svg = d3
          .select("#mbr-container")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g");

        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 10])
          .on("zoom", (event) => {
            svg.attr("transform", event.transform);
          });

        d3.select("#mbr-container svg").call(zoom);

        // Get max depth and group nodes by level
        let maxDepth = 0;
        const levelNodes = [];

        function groupByLevel(node, depth = 0) {
          maxDepth = Math.max(maxDepth, depth);
          if (!levelNodes[depth]) {
            levelNodes[depth] = [];
          }
          levelNodes[depth].push(node);
          if (node.children) {
            node.children.forEach((child) => groupByLevel(child, depth + 1));
          }
        }
        groupByLevel(treeData);

        createLevelControls(maxDepth);

        // Render MBRs level by level, from deepest to root
        for (let depth = maxDepth; depth >= 0; depth--) {
          levelNodes[depth].forEach((node) => {
            const mbr = node.mbr;
            svg
              .append("rect")
              .attr("class", `mbr mbr-level-${depth}`)
              .attr("x", xScale(mbr.minX))
              .attr("y", yScale(mbr.maxY))
              .attr("width", xScale(mbr.maxX) - xScale(mbr.minX))
              .attr("height", yScale(mbr.minY) - yScale(mbr.maxY))
              .append("title")
              .text(`Level: ${depth}`);
          });
        }
      }

      // Render visualization when the page loads
      if (treeData) {
        renderMBRs();
      }
    </script>
  </body>
</html>
